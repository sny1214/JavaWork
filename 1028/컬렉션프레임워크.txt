1. 컬렉션 프레임웍(Collection Framework)
   - '데이터 군'을 저장하는 클래스들을 표준화한 설계를 뜻한다.
   - 컬렉션(Collection)은 다수의 데이터, 즉 데이터 그룹을 의미한다.
   - 프레임웍(Framework)는 표준화된 프로그램 방식을 의미한다.
   ----------------------------------------------------------------------------------------
   대량의 데이터를 관리하기 위한 클래스들을 표준화된 설계방식을 적용하여 만들어진 클래스 라이브러리를 총칭하여
   컬렉션 프레임워크라고 부른다. java언어에서는 java.util 패키지에 다양한 클래스(interface, class, abstract class, enum,..)
   형태로 제공하고 있다.   
   
   - 자료 구조와 관련된 클래스를 모아놓은 클래스 라이브러리 이다.
   
2. 자료구조(DataStructure) : 주 메모리 공간에 대량의 데이터를 효율적으로 관리하기 위해
						   데이터 저장 구조를 어떻게 설계할 것이고, 이 데이터들을
						   추가/수정/삭제/검색/정렬 등의 필요기능을 어떻게 구성할
						   것인지를 연구하는 분야
						   
	1. 선형구조(처음/끝, 이전/다음)
	   1) 순수선형 구조 ( 배열, List ) : 데이터의 추가/삭제 위치가 자유롭다
	   
	   	  (메모리의 저장구조)
	      - 배열을 이용한 저장구조
	      	장점) 빠르게 데이터를 접근(access)할 수 있다.
	      	단점) 최대용량을 미리 예측하여 공간을 확보해 놓아야 한다. 
	      		 데이터의 추가 및 삭제 시 기존 데이터의 변동이 생기므로 속도가 느리다.
	      	
	      										v----배열 최대 크기
	      					int arr[] = new int[5]; ============Java 언어============> ArrayList
	  							    	|0|0|0|0|0|
	      		 기능 					
	      	------------------  		  v---------------데이터 처음부터 차례로 들어가야(연속적으로)
	      	10,20,30을 추가 	   		    |10|20|30|0|0|		
	        40을 1번째 위치에 삽입  		|10|40|20|30|0| (뒤로 한칸씩 밀려남)
	        20을 삭제             		|10|40|30|0|0|
			40을 50으로 수정				|10|50|30|0|0|
			전체데이터를 순회(데이터 전체를 불러오는 것)
			순서대로 배치 - 정렬
			검색
			....		
		
		  -  링크를 이용한 저장구조
		     장점) 데이터 추가 및 삭제 시 링크만 조정하면 된다(빠르다)
		     단점) 링크 통해서 순차적으로 데이터를 접근하므로 접근 속도가 느리다.
		     
		  		1건 데이터 ==> 노드 = 데이터부 + 링크부
		  		
	  				  			class Node {		=> Single Linked List
	  				  				int value;		//data
	  				  				Node next;		//link (다음 데이터의 위치 정보)
	  				  			}
	  				  			
	  				  			class Node {		=> Double Linked List
	  				  				Node previous;	//link (이전 데이터의 위치 정보)
	  				  				int value;		//data
	  				  				Node next;		//link (다음 데이터의 위치 정보)
	  				  			}
	  				  			
	  				  	(***) 데이터를 운용하는 시점에서 메모리를 할당하여 사용한다. (미리 공간 확보x)
	  				  						  			
	  				  						  				   
	  				  						  			root 0x100		
	  				  						  			Node root = new Node(10); ====Java 언어====> LinkedList
	  				  						  			
	  				  	    	기능 					0x100 ---> [10, null]
	      				------------------  		 			   		  v-----|    v-----|
				      	10,20,30을 추가 	   		 				   [10, 0x100] [20,0x200] [30,null]
				        40을 1번째 위치에 삽입  					 
				        20을 삭제             		               
						40을 50으로 수정			
						전체데이터를 순회(데이터 전체를 불러오는 것)
						순서대로 배치 - 정렬
						검색
						....				
				  				  			
	  	2) 제한된 선형 구조 : 데이터의 추가/삭제 위치를 고정시켰다
	  		(1) 스택(stack) : 후입선출(LIFO) => 마지막에 추가된 데이터를 먼저 삭제한다.
	  						 추가와 삭제 위치가 같다(한곳)
	  		
	             (예)	10, 20, 30 을 추가하시오	|10|20|30|0|0|
	             		10, 20을 삭제하시오(x), 그냥 '삭제하시오' -> 가장 마지막에 추가된 데이터	삭제 (30->20->10 순으로 삭제)
	             											   |10|20|30|0|0| -> |10|20|0|0|0| -> |10|0|0|0|0|
	             		40을 추가하시오 |10|40|0|0|0|
	

			(2) 큐(queue) : 선입선출(FIFO) => 먼저 추가된 데이터가 먼저 삭제한다.
							추가와 삭제 위치가 다르다
								  		
								  				  |---rear 0(추가가 발생하는 위치)
								  				  | |---rear 1
								  				  | | |---rear 2 ...
												  v v v	v------rear 4							  				
								  				|0|0|0|0|0|
								  				^ ^ ^
								  				| | |--front2
								  				| |----front 1
								  				|------------front 0(삭제가 발생하는 위치)
								  		
	                (예) 10, 20, 30 을 추가하시오	|10|20|30|0|0|
	             	    10, 20을 삭제하시오(x), 그냥 '삭제하시오' -> 가장 먼저에 추가된 데이터 먼저 삭제 (10->20->30 순으로 삭제)
	             											   |10|20|30|0|0| -> |0|20|30|0|0| -> |0|0|30|0|0|
	             		40을 추가하시오 |0|0|30|40|0|

	
	         (3) 데큐(dequeue) : 스택과 큐를 하나의 구조로 결합

	2. 비선형구조 : 처음과 끝의 개념은 존재하지만 유일하지 않다.
		   가족 관계도	=============> 트리 구조 		   			조부모	
				ㅇ								   		v-----|----v
			  ㅇ   ㅇ							       형제1 형제2 형제3
	   	    ㅇ  ㅇㅇ	ㅇ							  v-----|----v
											     언니    나   동생       
											      
           지하철 노선도 =============> 그래프 구조     0      
           	    ㅇ                            	   v
           	  ㅇ   ㅇ						 0---->0---->0
 			ㅇ  	ㅇ	ㅇ							   v
 			  									   0
 			  									   
 			  									   
=============================================================================================================== 			  									   
 	===Java 언어에서는 표준적인 프로그램 기법을 적용(interface)하여 개발하기 쉽고(재사용)=============
 	===사용하기 편리(공통의 사용법)하고 유지보수 하기 편하도록 클래스 라이브러리 구축해 놓았다.============	
 	===그리고 이것을 Collection Framework 이라고 부른다.======================================	  	
			 	
			 	    	<<interface>>
			 		  ____Collection____
			 	   (상속)     		  (상속)   		
			 		 |					|
			  <<interface>>      <<interface>>      <<interface>>  
			   	  List			      Set			     Map => key+value의 쌍(pair)으로 데이터를 관리 ==> Entry클래스(로 1건의 Map표현)			
			    순서가 중요       순서는 중요하지 않음 	 key -   중복  불허
			    중복은 허용		중복은 불허	   		 value - 중복을 허용	
			      .						.					.
			      .						.					.
			      .	  <<interface>>		.					.
			      .		  Queue			.					.
			      .    					.					.
			  ========실제 우리가 사용법을 익혀 사용할 대표적인 클래스 ========   
			  V ArrayList			HashSet				HashMap
			    LinkedList			TreeSet				TreeMap
			    Stack			     ...
			    Vector									HashTable
			     ...								    Properties
			     										  ...
			     			
     										  
 	실제 ArrayList의 상속 계층구조
 	-----------------------------   										  
 	Object
	  AbstractCollection<E>		<<interface>>
		AbstractList<E>				List
		   ArrayList<E> 
		 
	실제 Vector의 상속 계층구조
 	-----------------------------  
    Object
	  AbstractCollection<E>		<<interface>>
		AbstractList<E>			     List
		   Vector<E>				
		   
		
 	우리가 실제로 사용할 ArrayList는 나름의 상속 계층을 가지고 있으면서
 	List interface를 구현하였다. 즉, List interface를 구현한 모든 클래스들의 List interface의
 	모든 추상메서드를 재정의하여 가지고 있으므로 공통의 사용법 역할을 가지고 있다.
 	
 	
 	컬렉션 프레임워크 클래스를 사용할 때 공통으로 적용되는 용어(메서드명)
 	==================================================================================================================================
 	List나 Set에서의 용어  (List 주로 순서 관련) (Set 순서 관련 표현x)					Map : 독자적인 용어 사용 <-(독자적인 구조 가짐 key+value)
 	
 	add 		: 데이터 추가														put
 	addAll		: 여러건의 데이터를 한번에 추가
 	clear		: 모든 데이터를 한꺼번에 삭제하기								
 	equals		: 같은지 여부
 	remove		: 데이터를 제거													remove
 	removeAll	: 한번에 여러 건의 데이터 제거
 	contains	: 데이터가 있는지 여부
 	size		: 데이터의 갯수
 	get			: 데이터 읽기(가져오기)											    get
 	set			: 데이터 변경하기(수정)
 	indexOf		: 데이터의 위치를 검색하기
 	empty		: 요소가 한개도 없는 지 여부
 	iterator	: 전체 요소를 빠짐없이 한방향에서 읽어오기
 				  (예전에는 enumeration으로 표현)
 	listIterator: 전체요소를 빠짐없이 양 방향에서 읽어오기
 				  																keySet 	 : key값들만 set으로 읽어오기
 				                                                 
  *** ArrayList의 사용법을 충분히 숙지하면 나머지 클래스들의 사용법은 어렵지 않습니다.
                                                 																values	 : Value들만 Collection으로 읽어오기
 	
-----------------------------------------------------------------------------------------------------------------------------------
ArrayList의 사용법
  - 내부적으로 배열을 이용하여 데이터를 순차적으로 관리
  - 실제 데이터를 저장하는 저장공간은 내부적으로 조정된다. 
  - 컬렉션 객체는 내부구성요소로 객체만 가질수 있다.
 
생성자
ArrayList()	: 기본 저장공간으로 10개의 데이터를 저장할 공간을 가지고 있다.
ArrayList​(int initialCapacity) : 최초 생성시 기본 저장공간 크기를 지정
ArrayList​(Collection<? extends E> c) : 최초 생성시 인자로 전달된 다른 컬렉션 객체와
									   동일한 값을 가지는 객체를 생성하는 것
		
참고) Iterator -- 다양한 커렉션 객체들의 내부 데이터 저장 구조가 모두 각기 다 다르다.
				 전체요소를 접근하려면 각 객체의 저장구조에 따른 다른 접근 방법을 사용하면 너무 불편하다.
				 그래서 공통된 접근방법을 제공하고 있다. 이것이 Iterator이다.
				 Iterator interface이다.
				 
				 Iterator it = 컬렉션객체.iterator();
				 
	 jdk에서 제공하는 interface나 abstract class를 이용하여 사용자가 직접 클래스를 만들어서
	 (interface이면 implements, abstract class 이면 상속받아 추상메서드를 overriding 시켜서)
	 객체를 생성할 수 있다.
	 
	 그런데 jdk내부에서도 interface나 추상클래스를 이용하여 만들어진 클래스가 존재할 수 있다.
	 
	
									   
참고) 타입 파라메터(Type parameter)를 적용하여 다양한 타입의 객체를 멤버변수나 메서드에서 다루게 하는 기법
	 ==> 일반화 프로그래밍 (Generics-지네릭스)
	 
	 (도움말 : ArrayList<E> 에서 E : 한건의 자료형)
	 (파라메터 안 정해주면 다 Object의 자료형으로 된다 --> 그러므로 모든 객체를 저장할 수 있다.)

	-------------------------------------------------------------------------------------- 
	 class A<T> {
	 	T value;			//멤버변수
	 	
	 	void method(T value ) {		//메서드의 매개변수
	 		this.value = value;
	 	}
	}
	---------------------------------------------------------------------------------------
	A 클래스는 객체 생성 시 주어지는 타입(자료형)에 의해 클래스의 구조가 완전해진다.
	A<Integer> aObj = new A<Integer>(); --> aObj만든 클래스의 원형은 <T> 사라지고 다 Integer로 바껴
	------------------------------------------------------------------------------------------
		 class A {
	 		Integer value;			//멤버변수
	 	
	 	void method(Integer value ) {		//메서드의 매개변수
	 		this.value = value;
	 	}
	}
	
	A<Integer> aObj = new A<Integer>();
	--------------------------------------------------------------------------------------------
	  |--A<String> aObj = new A<String>();
	--v---------------------------------------------------------------------------------------
		 class A {
	 		String value;			//멤버변수
	 	
	 	void method(String value ) {		//메서드의 매개변수
	 		this.value = value;
	 	}
	}
	
	A<String> aObj = new A<String>();
	--------------------------------------------------------------------------------------------

	

참고) 모든 컬렉션 객체는 내부구성요소로 객체만을 가진다. 즉 Object형(최상위 클래스)을 내부요소로 가진다는 의미					
	 Java 5.0버전 이후부터는 가급적이면 동일한 종류의 객체만을 내부요소로 관리하기를 권장한다.
	 그래서 컬렉션 객체 선언시 타입파라메터를 적용하기를 권장한다.
	 
	 ArrayList list = new ArrayList();
	 list.add(10);
	 list.add(new Date());
	 list.add(3.14);
	 list.add(new Item("새우깡",1000));
	 
	 //위의 표현이 편리한 것처럼 느껴지지만 실제 코딩에서는 많은 문제를 야기한다.
	 //그래서 한개의 자료형만 관리하는 ArrayList를 선언하여 사용하자.
	 
	 ArrayList<Integer> list = new ArrayList<Integer>();
	 		  ---------						---------
	 		  		|---------타입 파라메터---------|
	 		  		
	 list.add(10);
	 list.add(new Date()); //error ---> list.add(new Integer(20))
	 list.add(3.14);	   //error ---> list.add(Integer.valueOf(30));
	 list.add(new Item("새우깡",1000));			
	 		   
	 		   
	 		   
	 		   	 
	 
============================================================================================================	 
실무적인 코딩에서는 컬렉션 객체의 내부구성요소로 사용자가 만든 클래스의 객체를 관리하는 것이 대부분이다.	
---------------------> 1건의 데이타를 표현한 클래스
					   엔티티 클래스(Entitiy class), 커스텀 클래스(custom class), 자바빈(JavaBean)	 		
					   
만일 주소록 관리를 한다면 1건의 주소정보를 표현하기 위해
Profile클래스를 만들었다면 우리는 ArrayList를 다음과 같이 선언하여 사용할 것이다.

ArrayList<Profile> profiles = new ArrayList<Profile>();

//1건의 신상명세를 추가
Profile profile = new Profile("홍길동", 27, "010-1111-1111", "hong@daum.net", null);
profiles.add(profile);

--------------------------------------------------------------------------------------------------------------
Collections 클래스는 컬렉션 객체에서 공통으로 필요한 유용한 기능을 제공한다.
대표적으로 sort()메서드를 사용해보자.

커스텀 클래스를 구성요소로 가진 컬렉션 객체에서 정렬기능 수행하려면
내부적으로 비교하는 기능이 필요하다. 그래서 Comparable interface를 제공하고 있다.

우리는
1) 커스텀클래스에서 java.lang.Comparable 인터페이스를 구현하면
   정렬시 기본 비교방법으로 해당 메서드(compareTo())를 호출하여 그 결과에 따라 정렬한다.
	==> 기본 정렬 기준(단 1개만 작성)
	  
2) 다른 정렬 기준을 적용하고 싶다면 java.util.Comparator 인터페이스를 외부에서 구현하여 정렬시키면서
   정렬기준을 함께 사용한다.
	==> 다른 정렬 기준 (상황에 따라 여러개가 가능하다)
	  	 	
	교재 628 page~630page에 Comparable와 Comparator의 사용법이 설명되어 있다.
------------------------------------------------------------------------------------------------------------
Vector 클래스는 Java언어의 초창기부터 사용했던 선형구조로 데이터를 표현할 때 사용해 왔던 클래스이다.
Java 1.2이후 버전에서부터는 컬렉션 프레임워크에 포함해서 개선하여 클래스를 재정비 했다.
그러다 보니 예전의 메서드와 동일기능을 수행하는 새로운 메서드도 함께 사용된다.
또한, 내부저장공간 ==> capacity도 관리하는 기능을 가지고 있다.
일반적인 사용법은 ArrayList와 유사한데 추가적인 메서드도 가지고 있습니다.

Vector와 같은 클래스를 하위 호환성을 위한 클래스라고 부른다.

교재 591page의 MyVector class는 사용자가 Vector클래스를 직접 만든다면 이렇게 만들 수 있을 것이라는 의미의
예제 코드이다.
---------------------------------------------------------------------------------------------

LinkedList 사용법
	- ArrayList와 동일하게 순서가 중요하고, 데이터 중복을 허용한다.
	- 내부적으로 데이터를 저장하기 위해 Node를 이용한다(Node는 1건의 데이터)
		class Node{		==> single Link 				단방향 SingleLinkedList
			Object value;	//데이터
			Node next;		//다음 데이터의 위치정보
		}
		
		class Node{		==> double Link					양방향 DoubleLinkedList
			Node previous;								======================
			Object value;								java.util.LinkedList는 양방향 원형구조를 내부적으로
			Node next;
		}
		
	LinkedList list = new LinkedList();
	list.add(10);							v------|		v-------|
	list.add(20);				[null,10,0x200]	[0x100,20,0x300] [0x200,30,null]
	list.add(10);				0x100		|--> 0x200		|-->  0x300
	
	- 데이터의 추가나 삭제 작업이 용이하다(이유: 링크만 조절하면 ok)
	- 접근(access) 속도가 느리다.(링크를 따라서 검색)
	- LinkedList는 자체적으로 stack관련 메서드를 가지고 있다.
					데이터 추가 : push
					데이터 삭제 : pop
					
	- LinkedList는 Queue 인터페이스를 구현하였으므로 queue관련 메서드도 가지고 있다.
					데이터 추가 : offer
					데이터 삭제 : poll
				
	- ArrayList보다 좀더 풍부한 메서드를 가지고 있다.
	
	참고) System클래스의 public static long currentTimeMillis() 메서드는
		 1970년 1월 1일 0시 0분 0초 0ms -- 0
		 					  0.5초  -- 500
							  1초  -- 1000
							  2초  -- 2000
							  ~
		 2021년 10월 28일 16시 19분 47초 -- ? 1635402210409                        
		  
=================================================================================		  
LinkedList에는 스택과 큐 관련 메서드가 정의되어 있다.
또한 스택은 별도의 클래스 Stack도 존재한다.
Queue는 별도의 클래스가 없고 interface로 제공되고 LinkedList에서 Queue interface를 구현했다.

스택(Stack) : LIFO(Last In First Out) - 후입선출
	일상의 예) 접시쌓기, 막다른 골목의 자동차 주차, ...
	용어) 	 
			 |10|20| | | |
			       ^
			 	   |
			   top 2 
			 
			 10 추가				===> 추가 	 push	add
			 20 추가
			 30 추가
			 제거(삭제) - 30      ===> 삭제 	 pop	remove
			 읽어오기				===> 읽어오기  peek	
			     				===> 검색			search
			 
	별도의 Stack 클래스
   ===================
   boolean 		empty()
   E  peak()
   E  pop()
   E  push(E item)
   int 	search(Object o)
   
   
   
   LinkedList의 Stack관련 메서드
  ============================
   E  pop()
   E  remove()
   void push(E e)
   boolean add(E e)
   E peek()
   
   
큐(Queue) : FIFO(First In First Out) - 선입선출
	일상의 예) 택시정류장의 줄서기, ...
	용어)  삽입위치 rear  2
			      	   |
			           v
			      | |20|30| | |
			      ^
			      |
		  삭제위치 front 0 
		  
		  			 
			 10 추가				===> 추가 	 offer	
			 20 추가
			 30 추가
			 제거(삭제) - 30      ===> 삭제 	 poll	
			 읽어오기				===> 읽어오기  peek	
			     				===> 검색	 search
			     				
   
   	Queue의 Stack관련 메서드
  =========================
   E  peek()
   E  poll()
   boolean  offer(E e)
   ...
   			     			

  