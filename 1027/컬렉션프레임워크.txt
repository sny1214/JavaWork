1. 컬렉션 프레임웍(Collection Framework)
   - '데이터 군'을 저장하는 클래스들을 표준화한 설계를 뜻한다.
   - 컬렉션(Collection)은 다수의 데이터, 즉 데이터 그룹을 의미한다.
   - 프레임웍(Framework)는 표준화된 프로그램 방식을 의미한다.
   ----------------------------------------------------------------------------------------
   대량의 데이터를 관리하기 위한 클래스들을 표준화된 설계방식을 적용하여 만들어진 클래스 라이브러리를 총칭하여
   컬렉션 프레임워크라고 부른다. java언어에서는 java.util 패키지에 다양한 클래스(interface, class, abstract class, enum,..)
   형태로 제공하고 있다.   
   
   - 자료 구조와 관련된 클래스를 모아놓은 클래스 라이브러리 이다.
   
2. 자료구조(DataStructure) : 주 메모리 공간에 대량의 데이터를 효율적으로 관리하기 위해
						   데이터 저장 구조를 어떻게 설계할 것이고, 이 데이터들을
						   추가/수정/삭제/검색/정렬 등의 필요기능을 어떻게 구성할
						   것인지를 연구하는 분야
						   
	1. 선형구조(처음/끝, 이전/다음)
	   1) 순수선형 구조 ( 배열, List ) : 데이터의 추가/삭제 위치가 자유롭다
	   
	   	  (메모리의 저장구조)
	      - 배열을 이용한 저장구조
	      	장점) 빠르게 데이터를 접근(access)할 수 있다.
	      	단점) 최대용량을 미리 예측하여 공간을 확보해 놓아야 한다. 
	      		 데이터의 추가 및 삭제 시 기존 데이터의 변동이 생기므로 속도가 느리다.
	      	
	      										v----배열 최대 크기
	      					int arr[] = new int[5]; ============Java 언어============> ArrayList
	  							    	|0|0|0|0|0|
	      		 기능 					
	      	------------------  		  v---------------데이터 처음부터 차례로 들어가야(연속적으로)
	      	10,20,30을 추가 	   		    |10|20|30|0|0|		
	        40을 1번째 위치에 삽입  		|10|40|20|30|0| (뒤로 한칸씩 밀려남)
	        20을 삭제             		|10|40|30|0|0|
			40을 50으로 수정				|10|50|30|0|0|
			전체데이터를 순회(데이터 전체를 불러오는 것)
			순서대로 배치 - 정렬
			검색
			....		
		
		  -  링크를 이용한 저장구조
		     장점) 데이터 추가 및 삭제 시 링크만 조정하면 된다(빠르다)
		     단점) 링크 통해서 순차적으로 데이터를 접근하므로 접근 속도가 느리다.
		     
		  		1건 데이터 ==> 노드 = 데이터부 + 링크부
		  		
	  				  			class Node {		=> Single Linked List
	  				  				int value;		//data
	  				  				Node next;		//link (다음 데이터의 위치 정보)
	  				  			}
	  				  			
	  				  			class Node {		=> Double Linked List
	  				  				Node previous;	//link (이전 데이터의 위치 정보)
	  				  				int value;		//data
	  				  				Node next;		//link (다음 데이터의 위치 정보)
	  				  			}
	  				  			
	  				  	(***) 데이터를 운용하는 시점에서 메모리를 할당하여 사용한다. (미리 공간 확보x)
	  				  						  			
	  				  						  				   
	  				  						  			root 0x100		
	  				  						  			Node root = new Node(10); ====Java 언어====> LinkedList
	  				  						  			
	  				  	    	기능 					0x100 ---> [10, null]
	      				------------------  		 			   		  v-----|    v-----|
				      	10,20,30을 추가 	   		 				   [10, 0x100] [20,0x200] [30,null]
				        40을 1번째 위치에 삽입  					 
				        20을 삭제             		               
						40을 50으로 수정			
						전체데이터를 순회(데이터 전체를 불러오는 것)
						순서대로 배치 - 정렬
						검색
						....				
				  				  			
	  	2) 제한된 선형 구조 : 데이터의 추가/삭제 위치를 고정시켰다
	  		(1) 스택(stack) : 후입선출(LIFO) => 마지막에 추가된 데이터를 먼저 삭제한다.
	  						 추가와 삭제 위치가 같다(한곳)
	  		
	             (예)	10, 20, 30 을 추가하시오	|10|20|30|0|0|
	             		10, 20을 삭제하시오(x), 그냥 '삭제하시오' -> 가장 마지막에 추가된 데이터	삭제 (30->20->10 순으로 삭제)
	             											   |10|20|30|0|0| -> |10|20|0|0|0| -> |10|0|0|0|0|
	             		40을 추가하시오 |10|40|0|0|0|
	

			(2) 큐(queue) : 선입선출(FIFO) => 먼저 추가된 데이터가 먼저 삭제한다.
							추가와 삭제 위치가 다르다
								  		
								  				  |---rear 0(추가가 발생하는 위치)
								  				  | |---rear 1
								  				  | | |---rear 2 ...
												  v v v	v------rear 4							  				
								  				|0|0|0|0|0|
								  				^ ^ ^
								  				| | |--front2
								  				| |----front 1
								  				|------------front 0(삭제가 발생하는 위치)
								  		
	                (예) 10, 20, 30 을 추가하시오	|10|20|30|0|0|
	             	    10, 20을 삭제하시오(x), 그냥 '삭제하시오' -> 가장 먼저에 추가된 데이터 먼저 삭제 (10->20->30 순으로 삭제)
	             											   |10|20|30|0|0| -> |0|20|30|0|0| -> |0|0|30|0|0|
	             		40을 추가하시오 |0|0|30|40|0|

	
	         (3) 데큐(dequeue) : 스택과 큐를 하나의 구조로 결합

	2. 비선형구조 : 처음과 끝의 개념은 존재하지만 유일하지 않다.
		   가족 관계도	=============> 트리 구조 		   			조부모	
				ㅇ								   		v-----|----v
			  ㅇ   ㅇ							       형제1 형제2 형제3
	   	    ㅇ  ㅇㅇ	ㅇ							  v-----|----v
											     언니    나   동생       
											      
           지하철 노선도 =============> 그래프 구조     0      
           	    ㅇ                            	   v
           	  ㅇ   ㅇ						 0---->0---->0
 			ㅇ  	ㅇ	ㅇ							   v
 			  									   0
 			  									   
 			  									   
=============================================================================================================== 			  									   
 	===Java 언어에서는 표준적인 프로그램 기법을 적용(interface)하여 개발하기 쉽고(재사용)=============
 	===사용하기 편리(공통의 사용법)하고 유지보수 하기 편하도록 클래스 라이브러리 구축해 놓았다.============	
 	===그리고 이것을 Collection Framework 이라고 부른다.======================================	  	
			 	
			 	    	<<interface>>
			 		  ____Collection____
			 	   (상속)     		  (상속)   		
			 		 |					|
			  <<interface>>      <<interface>>      <<interface>>  
			   	  List			      Set			     Map => key+value의 쌍(pair)으로 데이터를 관리 ==> Entry클래스(로 1건의 Map표현)			
			    순서가 중요       순서는 중요하지 않음 	 key -   중복  불허
			    중복은 허용		중복은 불허	   		 value - 중복을 허용	
			      .						.					.
			      .						.					.
			      .	  <<interface>>		.					.
			      .		  Queue			.					.
			      .    					.					.
			  ========실제 우리가 사용법을 익혀 사용할 대표적인 클래스 ========   
			  V ArrayList			HashSet				HashMap
			    LinkedList			TreeSet				TreeMap
			    Stack			     ...
			    Vector									HashTable
			     ...								    Properties
			     										  ...
			     			
     										  
 	실제 ArrayList의 상속 계층구조
 	-----------------------------   										  
 	Object
	  AbstractCollection<E>		<<interface>>
		AbstractList<E>				List
		   ArrayList<E> 
		 
	실제 Vector의 상속 계층구조
 	-----------------------------  
    Object
	  AbstractCollection<E>		<<interface>>
		AbstractList<E>			     List
		   Vector<E>				
		   
		
 	우리가 실제로 사용할 ArrayList는 나름의 상속 계층을 가지고 있으면서
 	List interface를 구현하였다. 즉, List interface를 구현한 모든 클래스들의 List interface의
 	모든 추상메서드를 재정의하여 가지고 있으므로 공통의 사용법 역할을 가지고 있다.
 	
 	
 	컬렉션 프레임워크 클래스를 사용할 때 공통으로 적용되는 용어(메서드명)
 	==================================================================================================================================
 	List나 Set에서의 용어  (List 주로 순서 관련) (Set 순서 관련 표현x)					Map : 독자적인 용어 사용 <-(독자적인 구조 가짐 key+value)
 	
 	add 		: 데이터 추가														put
 	addAll		: 여러건의 데이터를 한번에 추가
 	clear		: 모든 데이터를 한꺼번에 삭제하기								
 	equals		: 같은지 여부
 	remove		: 데이터를 제거													remove
 	removeAll	: 한번에 여러 건의 데이터 제거
 	contains	: 데이터가 있는지 여부
 	size		: 데이터의 갯수
 	get			: 데이터 읽기(가져오기)											    get
 	set			: 데이터 변경하기(수정)
 	indexOf		: 데이터의 위치를 검색하기
 	empty		: 요소가 한개도 없는 지 여부
 	iterator	: 전체 요소를 빠짐없이 한방향에서 읽어오기
 				  (예전에는 enumeration으로 표현)
 	listIterator: 전체요소를 빠짐없이 양 방향에서 읽어오기
 				  																keySet 	 : key값들만 set으로 읽어오기
 				  																values	 : Value들만 Collection으로 읽어오기
 	
-----------------------------------------------------------------------------------------------------------------------------------
ArrayList의 사용법
  - 내부적으로 배열을 이용하여 데이터를 순차적으로 관리
  - 실제 데이터를 저장하는 저장공간은 내부적으로 조정된다. 
  - 컬렉션 객체는 내부구성요소로 객체만 가질수 있다.
 
생성자
ArrayList()	: 기본 저장공간으로 10개의 데이터를 저장할 공간을 가지고 있다.
ArrayList​(int initialCapacity) : 최초 생성시 기본 저장공간 크기를 지정
ArrayList​(Collection<? extends E> c) : 최초 생성시 인자로 전달된 다른 컬렉션 객체와
									   동일한 값을 가지는 객체를 생성하는 것
									   

참고) 모든 컬렉션 객체는 내부구성요소로 객체만을 가진다. 즉 Object형(최상위 클래스)을 내부요소로 가진다는 의미					
	 Java 5.0버전 이후부터는 가급적이면 동일한 종류의 객체만을 내부요소로 관리하기를 권장한다.
	 그래서 컬렉션 객체 선언시 타입파라메터를 적용하기를 권장한다.
	 
	 ArrayList list = new ArrayList();
	 list.add(10);
	 list.add(new Date());
	 list.add(3.14);
	 list.add(new Item("새우깡",1000));
	 
	 //위의 표현이 편리한 것처럼 느껴지지만 실제 코딩에서는 많은 문제를 야기한다.
	 //그래서 한개의 자료형만 관리하는 ArrayList를 선언하여 사용하자.
	 
	 ArrayList<Integer> list = new ArrayList<Integer>();
	 		  ---------						---------
	 		  		|---------타입 파라메터---------|
	 		  		
	 list.add(10);
	 list.add(new Date()); //error ---> list.add(new Integer(20))
	 list.add(3.14);	   //error ---> list.add(Integer.valueOf(30));
	 list.add(new Item("새우깡",1000));			
	 		   